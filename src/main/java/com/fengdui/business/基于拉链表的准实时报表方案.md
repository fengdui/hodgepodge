1)     全量表
* 每天的数据都是最新的而且是最全的，如果有新增数据，全量表的每一天的分区包括之前所有的历史数据和当天新增的数据总和。
* 全量表以天为单位，查询的时候要卡一天，超过一天则会有重复数据。

* 后缀-da  (day all)
* 全量表查询时，要注意卡分区dt，dt=sysdate(-1)为昨天的分区的全部数据。
* 案例：
* select distinct user_log_acct from gdm_m01_userinfo_basic_sum where dt='2014-07-01' and first_create_ord_tm >= '2014-07-01'

2)     增量表
* 每天有数据更新的情况下，每天的数据只有新增的那一部分。
* 查询时需要根据需求卡一个时间段。
* 案例：
* select *  from gdm.gdm_online_log where dt=某日  某日当天产生的线上数据select  *  from fdm.fdm_wms_cals_jd_scanlog  where  dt>=某日  某日之后线上产生的数据select sale_ord_valid_flag – 订单有效标志  ,sum(COALESCE(sale_qtty,0)) as sale_qtty  – 商品销量  ,sum(COALESCE(before_prefr_amount,0)) as before_prefr_amount – 优惠前金额  ,sum(COALESCE(after_prefr_amount,0)) as after_prefr_amount – 优惠后金额  ,count(distinct sale_ord_id) as sale_ord_num – 订单量  from gdm.gdm_m04_ord_det_sum  where dt>='2014-10-01' and sale_ord_dt>='2014-10-01' and sale_ord_dt <'2014-11-01' and item_sku_id=1221864  and sale_ord_valid_flag=1  group by sale_ord_valid_flag  取下单时间在10月份item_sku_id=1221864 的订单量、金额等

3)     拉链表(重要)
* 当数据量比较大，表中的某些字段会有变化或者修改，但是变化的频率不大，不是每天都会变，但是我们又需要统计出这种状态。
* 如果每天全量一份，因为变化频率不大，有可能造成浪费空间，且业务统计麻烦。
* 而拉链表正好可以解决这个问题。
* 记录一个事物从开始，一直到当前状态的所有变化的信息
* dp=HISTORY/dt=2014-06-22/end_date=4712-12-31  ......  dp=HISTORY/dt=2014-06-23/end_date=4712-12-31  dp=HISTORY/dt=2014-06-24/end_date=4712-12-31  ......  dp=EXPIRED/dt=2013-10-11/end_date=2013-10-11  dp=EXPIRED/dt=2013-10-12/end_date=2013-10-12  dp=EXPIRED/dt=2013-10-13/end_date=2013-10-13  dp=EXPIRED/dt=2013-10-14/end_date=2013-10-14  ......  dp=ACTIVE /dt=4712-12-31/end_date=4712-12-31

* 拉链表命名：
* FDM + 源库名称 源表名 chain （拉链表仅存在于FDM层）
* 也就是说看到chain的就是拉链表，但是有的可能不带，主要请参考数据知识的简介。
* 分区：dp，dt，end_date
* 使用：start_date和end_date进行日期范围控制 start_date<=#date# and end_date>#date# 可以取某日全量数据的快照。
* 注意：start_date是字段不是分区。



* 如果还不是很了解就接着往下看：
* 首先，你要思考一个问题，为什么要有拉链表的存在？
* 现在提出一个需求，我希望设计一个表，能记录出一条修改过得信息的所有历史数据。
* 序号Sku流程1鼠标下单
* 假设我有这么一条数据，当我需要修改年龄，那么我就需要把年龄是25的这个打上一个版本标记是旧数据
* 序号Sku流程版本状态1鼠标下单旧2鼠标付款新
* 此时你就能通过一卡版本来确定什么是最新的数据，但是现在还少了一个最主要的维度，就是时间维度，如果我想看九月份最新的数据怎么办，而新的数据有可能被修改了很多份，如何区分旧数据，此时就需要引入两个时间维度，创建日期和结束日期。
* 序号Sku流程版本状态创建日期结束日期1鼠标下单旧2017-1-12017-1-22鼠标付款旧2017-1-22017-1-33鼠标送货新2017-1-34712-12-31
* 此时你就能通过日期来查找某个时间段内的某个数据的所有版本的历史数据。
* 这是个时候出现一个新的问题
* 序号Sku流程版本状态创建日期结束日期1鼠标下单旧2017-1-12017-1-12鼠标付款旧2017-1-12017-1-13鼠标送货新2017-1-14712-12-31
* 如果我在一天内修改了一份数据，如何判断其先后顺序，那么其实只要再加入一个更比日期更细粒度的时间就可以，比如年月日到时分秒，如下图，创建日期和结束日期用来确定版本的唯一性，创建时间和更新时间则是更细粒度的去表示创建和修改的时间点。
* 序号Sku流程版本创建日期结束日期创建时间更新时间1鼠标下单旧2017-1-12017-1-12017-1-1 08:58:352017-1-1 08:58:352鼠标付款旧2017-1-12017-1-12017-1-1 08:58:352017-1-1 10:00:353鼠标送货新2017-1-14712-12-312017-1-1 08:58:352017-1-1 16:00:00
* 此时，当我们的数据不需要再修改，比如说现在的一个订单已经结束，最新版本的数据不会再变化，那么我在每次查未结束的最新版本的订单的时候每次都会把已经结束完成的订单也遍历出来，但是我并不需要，于是就多了另一个版本分区，就是历史分区。已完成的订单超过45天后会被放入历史分        区。Dt就是放入历史分区的时间，而结束日期仍然是无穷大，因为只要有效数据结束日期就是无穷大。
* 序号Sku流程版本Dt(更新日期)创建日期结束日期(有效期)创建时间更新时间1鼠标下单旧2017-1-22017-1-12017-1-22017-1-1 08:58:352017-1-2 08:58:352鼠标付款旧2017-1-32017-1-22017-1-32017-1-1 08:58:352017-1-3 10:00:353鼠标送货旧2017-1-42017-1-32017-1-42017-1-1 08:58:352017-1-4 16:00:004鼠标签收(新)HIStory(2017-1-4)  2017-2-182017-1-44712-12-312017-1-1 08:58:352017-1-4 16:20:005键盘下单旧2017-11-12017-11-12017-11-12017-11-1 08:58:352017-11-1 08:58:356键盘付款旧2017-11-12017-11-12017-11-12017-11-1 08:58:352017-11-1 10:00:357键盘送货新2017-11-12017-11-14712-12-312017-11-1 08:58:352017-11-1 12:00:00
* 总结：
* 产生一条数据的时候，开始日期就有了，结束日期是个无穷大，数据发生变更以后，新的数据从新的一天开始，旧的数据就被打上一个结束的日期，每变化一次就多一条记录。
* Active存储的是当前最新状态的数据，expired是更新过的数据。
* 最新的数据dt都是最大的，因为是当前的没有更新就没有截至时间。
* 线上的数据比较多，完成的订单虽然也是最新数据，但是一般会把他放到历史数据表中去，和正在处理的数据区分开来，拉链表就把这部分的数据放到历史分区中去。哪天转到历史分区的dt就是那一天，转到历史分区不代表数据失效，仍然是有效数据。所以他的end_date也是一个无穷大，这时就和        dt区分开来了，并不是所有的dt都和end_date相同。

* 普通拉链表查询
* 查询最新状态卡dp=active即可，也可以通过卡当天的时间：
* start_date <= '最新时间' and end_date> '最新时间'
* 也可以通过将最新时间换为任何时间段查询该时间段内的数据的全部状态
* 如果dp只卡active分区，只有一个4712-12-31，如果卡HISTORY则有很多的归档日期，需要指定归档日期。
* select * from fdm.fdm_product_self_sku_1_chain where dp = 'ACTIVE' ;select * from fdm.fdm_product_self_sku_1_chain where start_date <= '2014-10-01' and end_date> '2014-10-01'

* 有结转拉链表查询
* select * from fdm.fdm_pek_orders_chain where dp = 'ACTIVE'  select * from fdm.fdm_pek_orders_chain where dp in ('ACTIVE','HISTORY') 相当于全局检索了  select * from fdm.fdm_pek_orders_chain where dt >= '2014-10-01'

* 各数据层的数据表分区使用简表

* 除以上，建议在使用前去think(数据知识)上查看表的用途描述、备注信息说明进行核对。
4)     流水表(了解即可，应用不多)
* 1、流水表对于表的每一个修改都会记录，可以用于反映实际记录的变更。
* 2、拉链表根据拉链粒度的不同，实际上相当于快照，只不过做了优化，去除了一部分不变的记录而已。
* 3、拉链表会更新历史数据，流水表不更新历史数据，其实拉链表就是更方便高效的记录数据的历史状态。
* 通过拉链表可以很方便的还原出拉链时点的客户记录。而流水表虽然也可能做得到，但是效率不行，或者需要人工参与。