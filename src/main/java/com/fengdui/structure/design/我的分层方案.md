# 1分层&&入参出参
* 涉及的模型:vo dto do。
* 为什么需要多个模型？
* 每个模型所处的作用域不一样, vo dto这些是对外暴露的模型, 除去敏感的数据和不需要的数据按需给到各个业务方, do是当前领域所使用的模型, 不应该暴露出去给web, dubbo等外层使用, 总之将各个层当成不同角色的"人"。
* 举个例子，有些同事对于vo和do混用，导致某个serivice方法现在是返回vo, 但是另外一个service是需要do的, 将vo这个模型给到了暴露到了其他层, 那vo是包括了一些前端需要渲染的一些字段，这些字段不仅仅是do能给到的，比如do只是关联了用户id, 用户名只在vo有，那这个service拿到vo之后某些字段是空的, 很有可能存在空指针问题，并且现在service依赖了client层。
* 其他
* 为什么需要分层？
* 严格的分层是为了让业务逻辑的的链路不至于过长，以及每层都有自己的职责, 每一层做好自己的事情，分工明确。
* 例如现在有一个接口的链路是这样的
* controller->service->wrapsercice->rpcservice->wrapservice->rpcservice->dao
* 链路很长, 没有办法做事务, 好几次都要某个数据做校验但又没有把需要的数据传到下一层，导致对于同一个数据查询了好几次，重复代码很多，业务逻辑无法内聚和重用，维护困难。
* 如果按照严格分层的做法，就能解决以上的问题。
   ## 1.1. web层&&dubbo层&openapi层&kafka&task层
   入参:vo(web) dto(dubbo) vo(openapi) dto(kafka)
   出参:vo(web) dto(dubbo) vo(openapi) dto(kafka)
   ### 1.1.1. 职责
   * 1.参数校验, 不做业务校验, 不包含业务逻辑，每一层各自的逻辑处理，如后台web层的sso权限校验, openapi的接口权限校验等。
   * 2.如果是一些跑批任务, 需要做大量循环查询之后处理, 可以将循环查询的逻辑写在该层, 对于处理的逻辑需要放在下层, 不能在改成对数据处理完之后直接调用下层的update方法。
   * 3.导入导出的可以在该层进行循环。
   ### 1.1.2. web层->service层
   * 1.调用service层前先将VO转成DTO, biz层返回DTO, 将DTO转成VO后返回。 
   * 因为biz层不仅仅是给web层调用, atop, dubbo层都会调用,需要转成一个通用的对象。如果上层统一是直接是用dto的, 可以不转直接传入。
   ## 1.2. service层
   ### 1.2.1. 职责
   * 1.聚合biz层业务 
   * 每个方法都是有业务含义的，看命名就能知道是做什么，比如根据ID查询或修改这样的方法是不建议的, 方法不够内聚，上游需要做额外的事情，重复代码就是这样产生的。
   * 2.发起rpc调用 
   * 3.事务注解开启
   * 4.重试的话需要注意下事务的隔离级别。
   * 5.分布式锁
   ### 1.2.2. service层->biz层
   * 1.调用biz层先将dto转换成do, service层做完增删改查之后返回do, biz层在将do转成dto。
   * 2.这里如果是双写db和es, 两边的do是不一致的，es一般是聚合成一张宽表。
   ## 1.3. biz层
   ### 1.3.1. 职责
   * 1.真正业务执行的地方。
   * 2.乐观锁重试。
   * 3.缓存。
   * 4.双写。
   ### 1.3.2. biz层->core层
   * 1.有些喜欢用example的小伙伴建议将example的拼接sql的代码抽到biz单独的方法或者单独搞一层。
   * 2.biz处理业务逻辑之后需要将do插入或者保存到db, 如果是双写的情况，需要保证数据一致(包括创建时间和更新时间)。
   ## 1.4. core层
   ### 1.4.1. 职责
   * 1.各种存储层, 目前pms涉及的有mongo, hbase, mysql, redis, es等实现。等同于dao层。
   * 这里需要做控制反转？
   * 2.不要实现dao接口。
   ## 1.5. intergration
   * 1.防腐层
   * 对应调用其他领域的接口返回的模型不适用情况，需要针对返回的结果进行统一转换
# 2. 命名规范

# 3. 异常处理
   dubbo对异常的处理是发现有异常会将异常封装起来放到rpcResult, 消费端发现rpcResult有异常会throw抛出异常，所以无需自行将异常包装起来。
# 4. 其他一些细节
   * 1.不要改写默认的get set方法。
   * 2.传参不使用map。
   * 3.各种模型拷贝属性和属性处理分开，如果某个字段是通过其他一系列字段计算得出的，属于业务代码，而非拷贝。
   * 4.atop接口，dubbo接口及时下线。