# tcc-transaction
* 查看源码的分支是master-1.2.x 时间2018.04.12
* 也是通过aop拦截业务方法，业务方法上带有Compensable注解
* 1 刚开始是trying阶段，先创建事务日志，状态为trying，然后进入业务方法发起rpc操作，链式的调用提供者的带有Compensable注解的业务方法，当某一个发起者不是root类型，则会使用rpc操作传过来的TransactionContext中的事务id创建事务日志
* 2 当最低层的提供者业务调用完之后，返回到上一层调用者的时候，如果没有错误，这进入confirm阶段，将事务日志状态设置为confirm，然后调用所有使用到的提供者的confirm方法，这里对于每一个发起者调用的提供者方法都会记录在participant中，cancel类似。
* 问题
* 如果trying阶段 过程中发起rpc操作，然后挂了，这时候日志信息状态是trying，但是看事务日志只处理了confirm和cancel。
* 看到第二个分支如果是cancel或者root类型的会rollback。

# myth
* 查看的源码是master分支 时间2018.04.10
* 这一款分布式事务中间件是基于mq进行补偿不支持回滚 所以发起rpc操作就意味着成功，注意调用的顺序
* 比如现在有一个发起者和两个提供者，发起者需要调用2个提供者暴露的服务
* 先看发起者
* 发起者在调用带有@myth注解的事务方法的时候，会先执行aop拦截，创建事务MythTransaction和MythTransactionContext，前者只用于某个服务和日志持久化，后者用于跨节点，让提供者知道当前事务的信息，
* 提供者创建完事务会扔一个阻塞队列，有一些work线程会不断的取出，然后持久化事务日志，持久化支持db，redis，zk等等方式，序列化方式也有很多选择，使用spi的方式
* 然后执行业务方法，这时候会发起rpc操作，发起操作会将提供者的信息保存到MythTransaction的mythParticipants，每添加一个参与者，就会把相关消息持久化，用作于发送mq
* 这行业务方法完成之后，进入到aop，在finally部分会进行发消息，当然可能这时候已经挂了，没有发，没关系，有一个线程池会不断取出状态为2即开始状态的mythParticipants日志，然后进行发队列操作，往所有提供者发完消息之后，会将事务日志的状态设置为1即已提交。
* 再看提供者 提供者先保存事务日志 状态为开始 然后业务方法，然后修改事务日志状态为提交。
* 提供者的方法正常情况下rpc操作会调用一次，然后发消息也会调用一次，所以接口要做幂等，比如可能做完业务方法，然后挂了，日志没有修改为提交，或者日志保存是异步的，消息过来还没有入库等等。
* 问题
* 1.发起者补偿操作发队列是基于日志的，日志的入库是异步的在阻塞队列中，要是业务已经发起rpc操作，这时候发起者的日志还没有保存就挂了，由于没有日志发起者重启之后不会补偿发消息。所以我觉得日志一定要有。
* 2.需要调用本地事务完成 在发起远程事务，不然本地失败了 还会发起rpc
* 3.updateParticipant更新是同步的 ，mythParticipants创建是异步的，怎么保证更新的时候数据存在？
