* 没有一种技术和架构能兼容所有业务场景, 需要根据实际情况去选型和完成问题 
# 多活
* 多机房多活架构 数据库互相同步
* 伪多机房多活架构 数据库主从 写都跨机房写主
* 迁移
* 专线
* 缓存迁移 缓存内网的dns切换
* 数据库readonly
* 消息队列迁移 最好包装一下 消费端双接收 生产者上线 消费上线

# 数据库备份
* 1小时延时从 双份一小时延时从
* pt online
* 长文本去重
* minhash md5
* 洗稿 tfidf

# 监控
* 集群信息管理
* http接口监控 页面监控 返回json数据的http接口
* log关键字监控
* 操作系统，进程，端口
* http状态码
* 服务存活性
* 接口处理时间
* 用户层面监控 布控 第三方
* RPC接口监控
* 分级告警
* 将监控分成基础设施、系统、应用、业务和用户端这几层，分完层后将每层的监控做到位。
# 容量
* 2 8 原则 压测 峰值
* 20/10/5，设计系统的时候，以实际流量的
* 20倍来设计：开发系统的时候，以实际
* 流量的10倍来开发系统：发布系统的时候，以实际流量的
* 5倍来部署。这只是一个通用的原则，可以根据实际情况来确定，不需要严格按照倍数来执行。
* Designforfailure，预测可能发生的问题，做好预案。

# 负责均衡
* lvs dns轮训


# 数据库
* 表扩展属性 version+ext json格式 key单独表维护 索引外置
* 异构数据 先写正表还是反表 看业务影响 实时校对 发两条消息校对 收到第一条只会埋怨收到第二条则修复
* 2n扩容 双虚ip 该路由规则 解除双虚ip 双主同步 新库做高可用 删除多余数据
* 双写扩容
# im
* 微信群覆盖 染色法 并查集
* 在线离线状态同步 拉取比推好 消息风暴扩散
* 系统通知 对1 推 对n拉
* 群消息 拉取
* 网页消息 long poling
* 微信朋友圈推模式 qzone拉模式 im微信im是推模式
* 拉模式=读扩散
* 推模式=写扩散
* 微博弱关系一般是读扩散 强关系 写扩散 查询鉴定
# 缓存
* 写key清缓存 同事设置一个key带上超时时间 读服务发现key hit 说明还没有同步 强制写主
* 缓存淘汰 先淘汰在写数据库 因为如果先写数据库然后淘汰缓存失败可能导致缓存数据不一致 写淘汰顶多会导致cache miss
* 可以专门做异构服务层 去数据从服务层取 对缓存的失效 淘汰等透明
* 异步监听缓存变更

* 缓存二次淘汰法 以为淘汰缓存只会可能业务还没有做完 比较耗时 数据库的值可以更新 所以读到的还是旧值 这时候在淘汰一次
* cache as sor
* read through
* write throuth
* write behind caching


# 推荐算法
* 协同过滤
* 我喜欢a 找到同样喜欢a的人 他们喜欢b给我推荐b
* 内容推荐
* 我喜欢的东西x由a,b,c组成 y由 b,c,d组成 找到同样有b,c属性的东西推荐
* 相似性推荐
* 算距离 曼哈顿距离
* 关联规则
* 直接从数据中挖掘潜在的关联，与个人的偏好无关

# 分表分库
* 全局视野法 limit x,y改写 0, x+y
* 禁止跳页查询 带上上一页的结果
* 允许模糊数据法 offset x,limit y 改成offset x/n, limit y/n
* 二次查询法
* 方法四：二次查询法
* （1）SQL改写，将
* order by time offset X limit Y;
* 改写成
* order by time offset X/N limit Y;
* （2）多页返回，找到最小值time_min；
* （3）between二次查询
* order by time between $time_min and $time_i_max;
* （4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset；
* （5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y；

# 线程池
* n核服务器 本地计算时间为x 等待时间为y 线程数为n*(x+y)/x

# 优化
* 跨公网调用
* 异步代理法 做一个中控服务 例如取token 上游直接取 中控服务定时去更新token 与第三方交互
* 第三方接口备份与切换法 超时切换其他服务
* 向第三方同步服务 本地写成功就算成功 异步同步

# linux
* 使用&后台运行程序：
* 结果会输出到终端
* 使用Ctrl + C发送SIGINT信号，程序免疫
* 关闭session发送SIGHUP信号，程序关闭

* 使用nohup运行程序：
* 结果默认会输出到nohup.out
* 使用Ctrl + C发送SIGINT信号，程序关闭
* 关闭session发送SIGHUP信号，程序免疫
* /dev/null 表示空设备文件
* 0 标准输入
* 1标准输出
* 2 标准错误
* 2>&1 > /dev/null  将标准输出重定向到标准输入 在重定向到/dev/null

# 分布式
* eph：采用CRUSH方式，由中心集群Monitor提供并维护集群拓扑的变化
* bully算法 环算法
* 单调写 单调读 写后读 读后写 fifo一致性 因果一致性 严格一致性 顺序一致性
* 分布式锁不要只有一把锁 多把锁也没问题
# 测试
* 影子测试 特性开关 
# zk 只保证同一个客户端看到的视图 2个客户端看到的视图不一致
# paxos zab区别
* baisc paxos 2阶段的变种 可能会存在第一阶段交替的情况
* multi paxos 将集群状态分成2个阶段 选主 之后变成了一阶段提交 依赖leader
* 与两阶段提交不同的是，三阶段提交有两个改动点。
* 1、引入超时机制。同时在协调者和参与者中都引入超时机制。
* 2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
* 将准备阶段一分为二 为了避免大部分做了prepare 然后又rollback
* 当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大
# 管理
* 用户故事地图 精益度量 看板方法 影响地图 敏捷开发 需求就绪完成
* 业务架构偏向业务领域划分，模型设计，对整体业务进行语言转化，内化为领域通用语言。


